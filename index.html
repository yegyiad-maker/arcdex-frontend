<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArcDEX Frontend - Bi-Directional Swap</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Ethers.js for blockchain interaction -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
    <!-- Load Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
        }
        /* Custom scrollbar for better aesthetics */
        /* Note: This is custom CSS, Tailwind does not have this utility */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #4f46e5; border-radius: 3px; }
        ::-webkit-scrollbar-track { background: #161b22; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- Main DEX Container -->
    <div id="dex-app" class="w-full max-w-lg bg-[#161b22] shadow-2xl rounded-xl p-6 md:p-8">
        <h1 class="text-3xl font-extrabold text-white text-center mb-6">
            <span class="text-indigo-400">ArcDEX</span> Interface
        </h1>

        <!-- Auth Status & Network Info -->
        <div class="text-xs text-gray-400 mb-4 flex justify-between items-center">
            <div id="auth-status" class="px-2 py-1 rounded-full bg-yellow-900 text-yellow-300">
                Authenticating...
            </div>
            <div id="network-status" class="flex items-center">
                <div class="h-2 w-2 rounded-full bg-red-500 mr-2" id="rpc-dot"></div>
                <span id="account-info">Wallet Not Connected</span>
            </div>
        </div>

        <!-- Reserves and Balance Display -->
        <div id="reserve-display" class="bg-[#0d1117] p-4 rounded-lg mb-6 border border-gray-700">
            <h2 class="text-lg font-semibold text-gray-300 mb-2">Pool Reserves & Your Balances</h2>
            <p id="reserve-a" class="text-sm text-green-400">MYTA Reserve: Loading...</p>
            <p id="reserve-b" class="text-sm text-purple-400">MYTB Reserve: Loading...</p>
            <hr class="my-2 border-gray-800">
            <p id="balance-a" class="text-sm text-gray-300">Your MYTA: Loading...</p>
            <p id="balance-b" class="text-sm text-gray-300">Your MYTB: Loading...</p>
        </div>
        
        <!-- Tab Navigation -->
        <div class="flex mb-4 border-b border-gray-700">
            <button id="tab-swap" onclick="showTab('swap')" class="flex-1 py-2 text-center text-lg font-semibold border-b-2 border-indigo-500 text-white transition-colors duration-200 hover:text-indigo-400">
                Swap
            </button>
            <button id="tab-liquidity" onclick="showTab('liquidity')" class="flex-1 py-2 text-center text-lg font-semibold border-b-2 border-transparent text-gray-500 transition-colors duration-200 hover:text-purple-400">
                Liquidity
            </button>
        </div>

        <!-- SWAP CARD -->
        <div id="swap-card" class="bg-[#0d1117] p-5 rounded-lg border border-indigo-700/50">
            <div class="space-y-4">
                <!-- Input Token (DYNAMIC) -->
                <div class="relative bg-[#161b22] p-3 rounded-xl border border-gray-700">
                    <label id="label-input" class="block text-sm font-medium text-gray-400 mb-1">You Pay (MYTA)</label>
                    <input type="number" id="input-amount" oninput="updateOutput()" placeholder="0.0"
                           class="w-full bg-transparent text-white text-2xl font-bold focus:outline-none placeholder-gray-600 appearance-none [appearance:textfield] [&::-webkit-inner-spin-button]:m-0 [&::-webkit-outer-spin-button]:m-0"/>
                    <div id="symbol-input" class="absolute right-3 top-3 px-3 py-1 bg-indigo-900/50 text-indigo-300 font-semibold rounded-lg">
                        MYTA
                    </div>
                </div>

                <!-- Swap Direction Icon + FLIP Button -->
                <div class="flex justify-center -my-2 z-10">
                    <button onclick="flipTokens()" title="Flip tokens" 
                            class="p-2 bg-gray-700 border-4 border-[#0d1117] rounded-full text-white shadow-lg transition-transform hover:rotate-180 hover:bg-indigo-500">
                        <!-- Icon for flip/swap -->
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L11 6.414V14a1 1 0 11-2 0V6.414L7.707 8.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>

                <!-- Output Token (DYNAMIC) -->
                <div class="relative bg-[#161b22] p-3 rounded-xl border border-gray-700">
                    <label id="label-output" class="block text-sm font-medium text-gray-400 mb-1">You Receive (MYTB)</label>
                    <input type="text" id="output-amount" placeholder="0.0" readonly
                           class="w-full bg-transparent text-white text-2xl font-bold focus:outline-none placeholder-gray-600 appearance-none [appearance:textfield] [&::-webkit-inner-spin-button]:m-0 [&::-webkit-outer-spin-button]:m-0"/>
                    <div id="symbol-output" class="absolute right-3 top-3 px-3 py-1 bg-purple-900/50 text-purple-300 font-semibold rounded-lg">
                        MYTB
                    </div>
                </div>
            </div>

            <!-- Price Impact & Fee -->
            <div class="text-xs text-gray-500 mt-4 space-y-1">
                <div class="flex justify-between">
                    <span>Price Impact:</span>
                    <span id="price-impact" class="text-red-400">--</span>
                </div>
                <div class="flex justify-between">
                    <span id="fee-label">Trade Fee (0.3% MYTA):</span>
                    <span id="trade-fee" class="text-gray-300">--</span>
                </div>
            </div>

            <!-- Action Button for Swap -->
            <button id="swap-button" onclick="handleSwap()"
                    class="w-full mt-6 py-3 px-4 rounded-xl text-lg font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors duration-200 disabled:bg-gray-600"
                    disabled>
                Loading...
            </button>
        </div>
        
        <!-- LIQUIDITY CARD -->
        <div id="liquidity-card" class="bg-[#0d1117] p-5 rounded-lg border border-purple-700/50 hidden">
            <h2 class="text-xl font-bold text-white mb-4">Add Initial Liquidity</h2>
            <div class="space-y-4">
                <!-- Input Token A -->
                <div class="relative bg-[#161b22] p-3 rounded-xl border border-gray-700">
                    <label class="block text-sm font-medium text-gray-400 mb-1">Amount MYTA</label>
                    <input type="number" id="input-amount-a" oninput="updateLiquidityRatio()" placeholder="0.0"
                           class="w-full bg-transparent text-white text-2xl font-bold focus:outline-none placeholder-gray-600 appearance-none [appearance:textfield] [&::-webkit-inner-spin-button]:m-0 [&::-webkit-outer-spin-button]:m-0"/>
                    <div class="absolute right-3 top-3 px-3 py-1 bg-indigo-900/50 text-indigo-300 font-semibold rounded-lg">
                        MYTA
                    </div>
                </div>

                <!-- Input Token B -->
                <div class="relative bg-[#161b22] p-3 rounded-xl border border-gray-700">
                    <label class="block text-sm font-medium text-gray-400 mb-1">Amount MYTB</label>
                    <input type="number" id="input-amount-b" placeholder="0.0"
                           class="w-full bg-transparent text-white text-2xl font-bold focus:outline-none placeholder-gray-600 appearance-none [appearance:textfield] [&::-webkit-inner-spin-button]:m-0 [&::-webkit-outer-spin-button]:m-0"/>
                    <div class="absolute right-3 top-3 px-3 py-1 bg-purple-900/50 text-purple-300 font-semibold rounded-lg">
                        MYTB
                    </div>
                </div>
            </div>

            <p id="liquidity-note" class="text-xs text-gray-500 mt-4">
                Note: For initial liquidity, both amounts must be greater than zero. Subsequent deposits must match the current pool ratio.
            </p>

            <!-- Action Button for Liquidity -->
            <button id="add-liquidity-button" onclick="handleAddLiquidity()"
                    class="w-full mt-6 py-3 px-4 rounded-xl text-lg font-bold text-white bg-purple-600 hover:bg-purple-700 transition-colors duration-200 disabled:bg-gray-600">
                Add Liquidity
            </button>
        </div>

        <!-- Error/Message Box -->
        <div id="message-box" class="mt-4 p-3 hidden rounded-lg text-sm" role="alert"></div>

    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let db, auth;
        let isAuthReady = false;

        if (firebaseConfig) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            window.db = db; // Attach to window for global access if needed
            window.auth = auth;

            // Auth Listener
            onAuthStateChanged(auth, async (user) => {
                const authStatusEl = document.getElementById('auth-status');
                if (user) {
                    authStatusEl.textContent = `User ID: ${user.uid.substring(0, 8)}...`;
                    authStatusEl.className = 'px-2 py-1 rounded-full bg-green-900 text-green-300 text-xs';
                    isAuthReady = true;
                    // Proceed to Ethers setup once authenticated
                    setupEthers();
                } else {
                    authStatusEl.textContent = 'Not Signed In';
                    authStatusEl.className = 'px-2 py-1 rounded-full bg-red-900 text-red-300 text-xs';
                }
            });

            // Sign in immediately using the custom token or anonymously
            async function authenticateUser() {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                    document.getElementById('auth-status').textContent = 'Auth Failed';
                }
            }
            authenticateUser();

        } else {
            document.getElementById('auth-status').textContent = 'Firebase Config Missing';
            // If config is missing, proceed directly to Ethers setup
            setupEthers();
        }

    </script>

    <!-- DEX Logic -->
    <script>
        // --- ✅ DEPLOYED CONTRACT ADDRESSES (CONFIRMED) ✅ ---
        // These addresses MUST match the successful deployment in your Forge scripts.
        const DEX_POOL_ADDRESS = "0x106A4bfb4b7709bc809dC01C4972e7DeC91b0f80"; 
        const MY_TOKEN_A_ADDRESS = "0xa654C7Ef6Ba495A77550D629f2b05bEF3e15c588";   
        const MY_TOKEN_B_ADDRESS = "0xECE33627200cA2430058EFFe099112852C65A5D6";   
        // ----------------------------------------------------

        // Token Configuration Map
        const TOKEN_INFO = {
            MYTA: { 
                address: MY_TOKEN_A_ADDRESS, 
                symbol: "MYTA", 
                reserveId: "reserveA", 
                balanceId: "balance-a", 
                contractKey: "mytaContract",
                inputColor: 'indigo'
            },
            MYTB: { 
                address: MY_TOKEN_B_ADDRESS, 
                symbol: "MYTB", 
                reserveId: "reserveB", 
                balanceId: "balance-b", 
                contractKey: "mytbContract",
                inputColor: 'purple'
            }
        };

        // Standard ERC-20 ABI (only includes approve, transferFrom, and balanceOf)
        const ERC20_ABI = [
            "function approve(address spender, uint256 amount) returns (bool)",
            "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)",
            "function balanceOf(address account) view returns (uint256)",
            "function symbol() view returns (string)"
        ];

        // Custom DEX Pool ABI (includes swap and addLiquidity)
        const DEX_ABI = [
            "function reserve0() view returns (uint256)", // Updated to match Solidity name
            "function reserve1() view returns (uint256)", // Updated to match Solidity name
            "function TOKEN_0() view returns (address)",
            "function TOKEN_1() view returns (address)",
            "function swap(address _tokenIn, uint256 _amountIn)",
            "function addLiquidity(uint256 amountA, uint256 amountB)",
        ];

        // Global state
        let state = {
            provider: null,
            signer: null,
            dexContract: null,
            mytaContract: null,
            mytbContract: null,
            reserveA: 0n,
            reserveB: 0n,
            isPoolReady: false,
            currentTab: 'swap',
            tokenInKey: 'MYTA', // Default input token is MYTA
            tokenOutKey: 'MYTB', // Default output token is MYTB
            token0Address: '', // Store the sorted token 0 address
            token1Address: '', // Store the sorted token 1 address
        };

        // UI elements
        const swapButton = document.getElementById('swap-button');
        const liquidityButton = document.getElementById('add-liquidity-button');
        const inputAmountEl = document.getElementById('input-amount');
        const outputAmountEl = document.getElementById('output-amount');
        const inputAmountAEl = document.getElementById('input-amount-a');
        const inputAmountBEl = document.getElementById('input-amount-b');
        const rpcDot = document.getElementById('rpc-dot');
        const accountInfoEl = document.getElementById('account-info');
        const msgBox = document.getElementById('message-box');

        /**
         * Switches the active tab (Swap or Liquidity).
         * @param {string} tabName 'swap' or 'liquidity'.
         */
        function showTab(tabName) {
            state.currentTab = tabName;
            document.getElementById('swap-card').classList.toggle('hidden', tabName !== 'swap');
            document.getElementById('liquidity-card').classList.toggle('hidden', tabName !== 'liquidity');

            document.getElementById('tab-swap').classList.toggle('border-indigo-500', tabName === 'swap');
            document.getElementById('tab-swap').classList.toggle('text-white', tabName === 'swap');
            document.getElementById('tab-swap').classList.toggle('border-transparent', tabName !== 'swap');
            document.getElementById('tab-swap').classList.toggle('text-gray-500', tabName !== 'swap');

            document.getElementById('tab-liquidity').classList.toggle('border-purple-500', tabName === 'liquidity');
            document.getElementById('tab-liquidity').classList.toggle('text-white', tabName === 'liquidity');
            document.getElementById('tab-liquidity').classList.toggle('border-transparent', tabName !== 'liquidity');
            document.getElementById('tab-liquidity').classList.toggle('text-gray-500', tabName !== 'liquidity');
        }

        /**
         * Utility to display messages/errors in the dedicated box.
         * @param {string} message The message content.
         * @param {string} type 'success', 'error', or 'info'.
         */
        function displayMessage(message, type = 'info') {
            msgBox.textContent = message;
            msgBox.classList.remove('hidden', 'bg-red-900', 'bg-green-900', 'bg-blue-900', 'text-red-300', 'text-green-300', 'text-blue-300');
            
            if (type === 'error') {
                msgBox.classList.add('bg-red-900', 'text-red-300');
            } else if (type === 'success') {
                msgBox.classList.add('bg-green-900', 'text-green-300');
            } else {
                msgBox.classList.add('bg-blue-900', 'text-blue-300');
            }
        }

        /**
         * Converts BigInt or string balance (in smallest unit) to a readable fixed-point number (e.g., 18 decimals).
         */
        function formatUnits(amount, decimals = 18) {
            try {
                return ethers.formatUnits(amount, decimals);
            } catch (e) {
                return "Error";
            }
        }

        /**
         * Converts a human-readable number string (e.g., "1.5") to BigInt (in smallest unit).
         */
        function parseUnits(amount, decimals = 18) {
            try {
                return ethers.parseUnits(amount, decimals);
            } catch (e) {
                return 0n;
            }
        }

        /**
         * Dynamically updates the UI labels, colors, and symbols based on the current swap direction.
         */
        function updateSwapUI() {
            const tokenIn = TOKEN_INFO[state.tokenInKey];
            const tokenOut = TOKEN_INFO[state.tokenOutKey];

            // Update Input Fields
            document.getElementById('label-input').textContent = `You Pay (${tokenIn.symbol})`;
            document.getElementById('symbol-input').textContent = tokenIn.symbol;
            document.getElementById('symbol-input').className = `absolute right-3 top-3 px-3 py-1 bg-${tokenIn.inputColor}-900/50 text-${tokenIn.inputColor}-300 font-semibold rounded-lg`;

            // Update Output Fields
            document.getElementById('label-output').textContent = `You Receive (${tokenOut.symbol})`;
            document.getElementById('symbol-output').textContent = tokenOut.symbol;
            document.getElementById('symbol-output').className = `absolute right-3 top-3 px-3 py-1 bg-${tokenOut.inputColor}-900/50 text-${tokenOut.inputColor}-300 font-semibold rounded-lg`;
            
            // Update Fee Label
            document.getElementById('fee-label').textContent = `Trade Fee (0.3% ${tokenIn.symbol}):`;

            // Reset calculation fields
            inputAmountEl.value = '';
            outputAmountEl.value = '0.0';
            document.getElementById('price-impact').textContent = '--';
            document.getElementById('trade-fee').textContent = '--';

            // Re-evaluate button state
            updateOutput();
        }

        /**
         * Flips the tokenIn and tokenOut keys and updates the UI.
         */
        function flipTokens() {
            [state.tokenInKey, state.tokenOutKey] = [state.tokenOutKey, state.tokenInKey];
            updateSwapUI();
        }

        /**
         * Sets up Ethers provider, signer, and contract instances.
         * FIX: Added explicit eth_requestAccounts call to force connection prompt and prevent hanging.
         */
        async function setupEthers() {
            try {
                // 1. Get Provider
                if (!window.ethereum) {
                    throw new Error("MetaMask or similar provider not detected.");
                }
                
                state.provider = new ethers.BrowserProvider(window.ethereum);

                // 2. Request accounts to force connection prompt and unblock signer access
                await state.provider.send('eth_requestAccounts', []);
                
                state.signer = await state.provider.getSigner();

                // 3. Display Account Info
                const address = await state.signer.getAddress();
                accountInfoEl.textContent = `Account: ${address.substring(0, 6)}...`;
                rpcDot.classList.replace('bg-red-500', 'bg-green-500');

                // 4. Setup Contracts
                state.dexContract = new ethers.Contract(DEX_POOL_ADDRESS, DEX_ABI, state.signer);
                state.mytaContract = new ethers.Contract(MY_TOKEN_A_ADDRESS, ERC20_ABI, state.signer);
                state.mytbContract = new ethers.Contract(MY_TOKEN_B_ADDRESS, ERC20_ABI, state.signer);
                
                // 5. Fetch Token Sorting (Crucial for reserve mapping)
                state.token0Address = await state.dexContract.TOKEN_0();
                state.token1Address = await state.dexContract.TOKEN_1();

                // 6. Fetch Reserves
                await getReserves();
                
            } catch (error) {
                console.error("Ethers Setup Error:", error);
                
                let errorMessage = "Connection failed. ";
                if (!window.ethereum) {
                    errorMessage += "Wallet provider (e.g., MetaMask) not found.";
                } else if (error.code === 4001) {
                    errorMessage += "Wallet connection rejected by the user.";
                } else {
                    errorMessage += `Ensure you are on the correct network (Arc Testnet). Error: ${error.message.substring(0, 50)}...`;
                }

                displayMessage(errorMessage, 'error');
                
                // Update UI to allow manual connection attempt
                accountInfoEl.textContent = "Wallet Disconnected";
                swapButton.textContent = "Connect Wallet";
                if (window.ethereum) {
                    swapButton.onclick = () => window.ethereum.request({ method: 'eth_requestAccounts' });
                } else {
                    swapButton.onclick = () => displayMessage("Please install a wallet provider (e.g., MetaMask).", 'error');
                }
                swapButton.disabled = false;
                liquidityButton.disabled = true;
            }
        }
        
        /**
         * Fetches and displays the current reserves and user balances from the DEX pool.
         */
        async function getReserves() {
            if (!state.dexContract || !state.signer || !state.token0Address || !state.token1Address) return;

            try {
                swapButton.textContent = "Fetching Data...";
                swapButton.disabled = true;
                liquidityButton.disabled = true;
                
                const userAddress = await state.signer.getAddress();

                // Fetch raw reserves
                const reserve0 = await state.dexContract.reserve0();
                const reserve1 = await state.dexContract.reserve1();
                
                // Map raw reserves (0 and 1) to MYTA and MYTB based on sorting in the contract
                const isMYTA_Token0 = state.token0Address.toLowerCase() === MY_TOKEN_A_ADDRESS.toLowerCase();
                
                state.reserveA = isMYTA_Token0 ? reserve0 : reserve1;
                state.reserveB = isMYTA_Token0 ? reserve1 : reserve0;
                state.isPoolReady = true;
                
                // Fetch user balances
                const balanceA = await state.mytaContract.balanceOf(userAddress);
                const balanceB = await state.mytbContract.balanceOf(userAddress);

                // Update UI (Reserves)
                document.getElementById(TOKEN_INFO.MYTA.reserveId).textContent = `MYTA Reserve: ${formatUnits(state.reserveA, 18)}`;
                document.getElementById(TOKEN_INFO.MYTB.reserveId).textContent = `MYTB Reserve: ${formatUnits(state.reserveB, 18)}`;
                
                // Update UI (Balances)
                document.getElementById(TOKEN_INFO.MYTA.balanceId).textContent = `Your MYTA: ${formatUnits(balanceA, 18)}`;
                document.getElementById(TOKEN_INFO.MYTB.balanceId).textContent = `Your MYTB: ${formatUnits(balanceB, 18)}`;
                
                msgBox.classList.add('hidden');

                // Check for zero reserves
                if (state.reserveA === 0n && state.reserveB === 0n) {
                    displayMessage("Pool has 0 reserves. Use the LIQUIDITY tab to add the first deposit.", 'info');
                    swapButton.textContent = "Add Liquidity First";
                    swapButton.disabled = true;
                    liquidityButton.disabled = false;
                    document.getElementById('liquidity-note').textContent = "Note: This is the initial deposit. Both amounts must be greater than zero.";
                } else {
                    swapButton.textContent = "Enter Amount";
                    swapButton.disabled = false;
                    liquidityButton.disabled = false;
                    document.getElementById('liquidity-note').textContent = "Note: Subsequent deposits must maintain the current pool ratio.";
                }

                // Recalculate based on current tab and swap direction
                if (state.currentTab === 'swap') {
                    updateOutput();
                } else {
                    updateLiquidityRatio();
                }

            } catch (error) {
                console.error("Error fetching data:", error);
                displayMessage("Could not fetch pool reserves or balances. Check contract addresses and network connection.", 'error');
                
                // Update UI elements to reflect failure state
                document.getElementById('reserve-a').textContent = `MYTA Reserve: --`;
                document.getElementById('reserve-b').textContent = `MYTB Reserve: --`;
                document.getElementById('balance-a').textContent = `Your MYTA: --`;
                document.getElementById('balance-b').textContent = `Your MYTB: --`;

                swapButton.textContent = "Error Loading";
                swapButton.disabled = true;
                liquidityButton.disabled = true;
            }
        }
        
        /**
         * Calculates the output amount using the Constant Product Market Maker formula:
         * amountOut = (amountIn * reserveOut * 997) / (reserveIn * 1000 + amountIn * 997)
         */
        function calculateSwapOutput(amountIn, reserveIn, reserveOut) {
            if (reserveIn === 0n || reserveOut === 0n || amountIn === 0n) return 0n;

            const feeNumerator = 997n; // 0.3% fee
            const feeDenominator = 1000n;
            
            const amountInWithFee = amountIn * feeNumerator;
            const denominator = (reserveIn * feeDenominator) + amountInWithFee;
            const numerator = amountInWithFee * reserveOut;
            const amountOut = numerator / denominator;
            
            return amountOut;
        }

        /**
         * Handles real-time input for swap and updates the estimated output based on direction.
         */
        function updateOutput() {
            if (!state.isPoolReady) return;

            const inputString = inputAmountEl.value;
            const inputVal = parseFloat(inputString);
            
            if (!inputString || isNaN(inputVal) || inputVal <= 0) {
                outputAmountEl.value = '0.0';
                document.getElementById('price-impact').textContent = '--';
                document.getElementById('trade-fee').textContent = '--';
                swapButton.textContent = "Enter Amount";
                swapButton.disabled = state.reserveA === 0n; 
                return;
            }

            try {
                const amountInWei = parseUnits(inputString, 18);
                
                // Determine reserves based on current swap direction
                const isAToB = state.tokenInKey === 'MYTA';
                const reserveIn = isAToB ? state.reserveA : state.reserveB;
                const reserveOut = isAToB ? state.reserveB : state.reserveA;
                
                const amountOutWei = calculateSwapOutput(amountInWei, reserveIn, reserveOut);
                const amountOutDisplay = formatUnits(amountOutWei, 18);
                outputAmountEl.value = parseFloat(amountOutDisplay).toFixed(6);

                // Update reserves for price impact calculation
                const reserveIn_after = reserveIn + amountInWei;
                const reserveOut_after = reserveOut - amountOutWei;
                
                let priceBefore, priceAfter;

                // Price is always Token B / Token A (Reserve B / Reserve A)
                const R_A = isAToB ? reserveIn : reserveOut;
                const R_B = isAToB ? reserveOut : reserveIn;
                
                priceBefore = Number(formatUnits(R_B)) / Number(formatUnits(R_A));
                priceAfter = Number(formatUnits(reserveOut_after)) / Number(formatUnits(reserveIn_after));

                // Price impact calculation
                const impact = ((priceAfter - priceBefore) / priceBefore) * 100;
                
                // Calculate Fee (0.3% of input)
                const tradeFeeWei = amountInWei * 3n / 1000n; 
                const tradeFeeDisplay = formatUnits(tradeFeeWei, 18);

                document.getElementById('price-impact').textContent = `${impact.toFixed(4)}%`;
                document.getElementById('trade-fee').textContent = `${parseFloat(tradeFeeDisplay).toFixed(6)} ${state.tokenInKey}`;

                swapButton.textContent = `Swap ${state.tokenInKey} for ${state.tokenOutKey}`;
                swapButton.disabled = false;

            } catch (error) {
                console.error("Swap Calculation Error:", error);
                outputAmountEl.value = 'Error';
                swapButton.textContent = "Error";
                swapButton.disabled = true;
            }
        }

        /**
         * Handles real-time input for liquidity and updates the proportional B amount.
         */
        function updateLiquidityRatio() {
            const inputStringA = inputAmountAEl.value;
            const inputStringB = inputAmountBEl.value;
            const inputValA = parseFloat(inputStringA);
            
            // If zero reserves, B is not proportional, and user sets both.
            if (state.reserveA === 0n && state.reserveB === 0n) {
                // If reserve B is being updated too, ensure it's not relying on A
                if (inputAmountBEl.value === '0.0' || inputAmountBEl.value === '') {
                     inputAmountBEl.value = inputStringA; // Simple 1:1 suggestion for initial liquidity
                }
                return; 
            }

            if (!inputStringA || isNaN(inputValA) || inputValA <= 0) {
                inputAmountBEl.value = '0.0';
                return;
            }
            
            try {
                // Calculate required B amount based on current ratio: B_out = A_in * (Reserve_B / Reserve_A)
                const ratio = Number(state.reserveB) / Number(state.reserveA);
                const amountB_num = inputValA * ratio;

                inputAmountBEl.value = amountB_num.toFixed(6);
                
            } catch (error) {
                console.error("Liquidity Calculation Error:", error);
                inputAmountBEl.value = 'Error';
            }
        }

        /**
         * Executes the approve and swap transactions, dynamically choosing the token to approve.
         */
        async function handleSwap() {
            if (!state.isPoolReady || !state.signer || swapButton.disabled) return;

            const inputString = inputAmountEl.value;
            if (parseFloat(inputString) <= 0 || !inputString) {
                displayMessage("Please enter a valid amount.", 'error');
                return;
            }
            const amountInWei = parseUnits(inputString, 18);
            const tokenIn = TOKEN_INFO[state.tokenInKey];
            
            swapButton.textContent = `Waiting for ${tokenIn.symbol} Approval...`;
            swapButton.disabled = true;

            try {
                // 1. Get the correct token contract (either MYTA or MYTB)
                const tokenContract = state[tokenIn.contractKey];

                // 2. Check/Execute Approve
                displayMessage(`Awaiting approval transaction for ${tokenIn.symbol}...`, 'info');
                // Approving MAX_INT is a common UX practice to only approve once
                const MAX_INT = 2n**256n - 1n; 
                const approveTx = await tokenContract.approve(DEX_POOL_ADDRESS, MAX_INT);
                await approveTx.wait();

                displayMessage(`${tokenIn.symbol} Approval confirmed. Awaiting Swap...`, 'info');

                // 3. Execute Swap
                const swapTx = await state.dexContract.swap(tokenIn.address, amountInWei);
                await swapTx.wait();

                displayMessage(`Swap successful! Tx: ${swapTx.hash.substring(0, 10)}...`, 'success');

            } catch (error) {
                console.error("Swap Transaction Failed:", error);
                const message = error.reason || error.message || "Unknown error during swap.";
                displayMessage(`Transaction Error: ${message}`, 'error');

            } finally {
                swapButton.textContent = `Swap ${state.tokenInKey} for ${state.tokenOutKey}`;
                swapButton.disabled = false;
                await getReserves();
            }
        }

        /**
         * Executes the approve and addLiquidity transactions.
         */
        async function handleAddLiquidity() {
            if (!state.isPoolReady || !state.signer || liquidityButton.disabled) return;

            const inputStringA = inputAmountAEl.value;
            const inputStringB = inputAmountBEl.value;
            const amountA = parseFloat(inputStringA);
            const amountB = parseFloat(inputStringB);

            if (amountA <= 0 || amountB <= 0 || isNaN(amountA) || isNaN(amountB)) {
                displayMessage("Please enter valid, non-zero amounts for both tokens.", 'error');
                return;
            }
            
            const amountAWei = parseUnits(inputStringA, 18);
            const amountBWei = parseUnits(inputStringB, 18);

            liquidityButton.textContent = "Waiting for Approval...";
            liquidityButton.disabled = true;

            try {
                const MAX_INT = 2n**256n - 1n;

                // 1. Approve Token A
                displayMessage("Awaiting approval transaction for MYTA...", 'info');
                let approveTxA = await state.mytaContract.approve(DEX_POOL_ADDRESS, MAX_INT);
                await approveTxA.wait();
                
                // 2. Approve Token B
                displayMessage("MYTA Approved. Awaiting approval transaction for MYTB...", 'info');
                let approveTxB = await state.mytbContract.approve(DEX_POOL_ADDRESS, MAX_INT);
                await approveTxB.wait();

                displayMessage(`Approvals confirmed. Awaiting Add Liquidity transaction...`, 'info');

                // 3. Add Liquidity
                // NOTE: The contract expects amounts corresponding to TOKEN_0 and TOKEN_1, 
                // but since the addLiquidity function is simplistic and checks the ratio 
                // against current balances, we pass A then B here as the contract handles the 
                // transferFrom calls internally in a sorted manner.
                const liquidityTx = await state.dexContract.addLiquidity(amountAWei, amountBWei);
                await liquidityTx.wait();

                displayMessage(`Liquidity added successfully! Tx: ${liquidityTx.hash.substring(0, 10)}...`, 'success');
                
            } catch (error) {
                console.error("Liquidity Transaction Failed:", error);
                const message = error.reason || error.message || "Unknown error during liquidity deposit. Check ratio or balances.";
                displayMessage(`Transaction Error: ${message}`, 'error');

            } finally {
                liquidityButton.textContent = "Add Liquidity";
                liquidityButton.disabled = false;
                await getReserves();
            }
        }

        // Expose functions globally for the HTML button clicks
        window.flipTokens = flipTokens;
        window.showTab = showTab;
        window.handleSwap = handleSwap;
        window.handleAddLiquidity = handleAddLiquidity;
        window.updateOutput = updateOutput;
        window.updateLiquidityRatio = updateLiquidityRatio;


        // Initialize Ethers on window load
        window.onload = function() {
            showTab('swap'); // Set default tab view
            // setupEthers is called by Firebase auth listener or fallback
            // Set up a refresh interval to keep reserves and balances updated
            setInterval(getReserves, 30000); 
        };
    </script>

</body>
</html>